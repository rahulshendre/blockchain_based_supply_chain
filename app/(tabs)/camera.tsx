import React, { useEffect, useRef, useState } from 'react';
import { StyleSheet, View, Text, TouchableOpacity, Alert } from 'react-native';
import { CameraView, useCameraPermissions, CameraType, BarcodeScanningResult } from 'expo-camera';
import { useRouter } from 'expo-router';
import { useQR } from '../../src/context/QRContext';
import { getSupplyChainContract, farmerWallet } from '../../src/utils/blockchain';
import { useFocusEffect } from '@react-navigation/native';

export default function CameraScreen() {
  const router = useRouter();
  const { setScannedData, scanningRole, canRoleScan, getNextAllowedRole } = useQR();
  const [permission, requestPermission] = useCameraPermissions();
  const [cameraType, setCameraType] = useState<CameraType>('back');
  const [scanned, setScanned] = useState(false);
  const [lastScannedCode, setLastScannedCode] = useState<string>('');
  const cameraRef = useRef<CameraView | null>(null);

  useEffect(() => {
    if (!permission) {
      requestPermission();
    }
  }, [permission, requestPermission]);

  // Clear previous scan code when role changes (e.g., Distributor -> Retailer)
  useEffect(() => {
    setScanned(false);
    setLastScannedCode('');
  }, [scanningRole]);

  // Also clear on screen focus to avoid stale debounce state across navigations
  useFocusEffect(
    React.useCallback(() => {
      setScanned(false);
      setLastScannedCode('');
      return () => {};
    }, [])
  );

  const handleBarcodeScanned = async ({ type, data }: BarcodeScanningResult) => {
    if (scanned) return; // Prevent duplicate scans
    
    // Debounce: ignore if same code scanned within 2 seconds
    if (data === lastScannedCode) return;
    
    setScanned(true);
    setLastScannedCode(data);
    
    // Validate that it looks like a UUID (batch ID format)
    const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
    if (!uuidRegex.test(data)) {
      Alert.alert('Invalid QR Code', 'This QR code does not contain a valid batch ID. Please scan a QR code generated by the Farmer.');
      setTimeout(() => setScanned(false), 2000);
      return;
    }

    // Determine next allowed role using on-chain state to avoid relying only on in-memory context
    try {
      const contract = getSupplyChainContract(farmerWallet);
      const info = await contract.getBatchInfo(data);
      const distributor = info[3];
      const retailer = info[4];
      const consumer = info[5];

      let nextAllowedRoleOnChain: 'Distributor' | 'Retailer' | 'Consumer' | null = null;
      const zero = '0x0000000000000000000000000000000000000000';
      if (!distributor || distributor === zero) {
        nextAllowedRoleOnChain = 'Distributor';
      } else if (!retailer || retailer === zero) {
        nextAllowedRoleOnChain = 'Retailer';
      } else if (!consumer || consumer === zero) {
        nextAllowedRoleOnChain = 'Consumer';
      } else {
        nextAllowedRoleOnChain = null; // all done
      }

      if (scanningRole && nextAllowedRoleOnChain && scanningRole !== nextAllowedRoleOnChain) {
        const roleMessages = {
          'Distributor': 'This batch is waiting for the Distributor to process it.',
          'Retailer': 'This batch is waiting for the Retailer to stock it.',
          'Consumer': 'This batch is ready for Consumer viewing only.'
        } as Record<string, string>;

        Alert.alert(
          'Access Restricted',
          `You are scanning as ${scanningRole}, but ${roleMessages[nextAllowedRoleOnChain] || 'this batch is not ready for your role.'}`,
          [
            {
              text: 'OK',
              onPress: () => setScanned(false),
            },
          ]
        );
        return;
      }
    } catch (e: any) {
      // If read fails, fall back to the existing in-memory validation
      if (scanningRole && !canRoleScan(data, scanningRole)) {
        const nextAllowedRole = getNextAllowedRole(data);
        const roleMessages = {
          'Farmer': 'This batch has already been created by the Farmer.',
          'Distributor': 'This batch is waiting for the Distributor to process it.',
          'Retailer': 'This batch is waiting for the Retailer to stock it.',
          'Consumer': 'This batch is ready for Consumer viewing only.'
        } as Record<string, string>;
        Alert.alert(
          'Access Restricted',
          `You are scanning as ${scanningRole}, but ${roleMessages[nextAllowedRole] || 'this batch is not ready for your role.'}`,
          [
            {
              text: 'OK',
              onPress: () => setScanned(false),
            },
          ]
        );
        return;
      }
    }

    Alert.alert(
      'QR Code Scanned!',
      `Batch ID: ${data}\n\nRole: ${scanningRole || 'Unknown'}`,
      [
        {
          text: 'Cancel',
          style: 'cancel',
          onPress: () => setScanned(false),
        },
        {
          text: 'Use This Batch ID',
          onPress: () => {
            // Store the scanned batch ID in context
            setScannedData(data, 'camera');
            // Navigate back to the previous screen
            router.back();
            setTimeout(() => setScanned(false), 1000);
          },
        },
      ]
    );
  };

  if (!permission) {
    return (
      <View style={styles.centered}><Text>Requesting camera permissionâ€¦</Text></View>
    );
  }

  if (!permission.granted) {
    return (
      <View style={styles.centered}>
        <Text style={styles.text}>We need your permission to use the camera.</Text>
        <TouchableOpacity style={styles.button} onPress={requestPermission}>
          <Text style={styles.buttonText}>Grant Permission</Text>
        </TouchableOpacity>
        <View style={styles.fallbackContainer}>
          <Text style={styles.fallbackText}>Camera not available?</Text>
          <TouchableOpacity 
            style={styles.fallbackButton} 
            onPress={() => router.back()}
          >
            <Text style={styles.fallbackButtonText}>Go Back to Manual Entry</Text>
          </TouchableOpacity>
        </View>
      </View>
    );
  }

  return (
    <View style={styles.container}>
      <CameraView
        style={StyleSheet.absoluteFill}
        facing={cameraType}
        ref={(ref) => (cameraRef.current = ref)}
        barcodeScannerSettings={{
          barcodeTypes: ['qr'],
        }}
        onBarcodeScanned={scanned ? undefined : handleBarcodeScanned}
      />

      <View style={styles.overlay}>
        <View style={styles.roleIndicator}>
          <Text style={styles.roleText}>Scanning as: {scanningRole || 'Unknown'}</Text>
        </View>
        <View style={styles.scanArea}>
          <View style={styles.scanFrame} />
        </View>
        <Text style={styles.scanText}>Position QR code within the frame</Text>
      </View>

      <View style={styles.controls}>
        <TouchableOpacity
          style={styles.controlButton}
          onPress={() => setCameraType((prev) => (prev === 'back' ? 'front' : 'back'))}
        >
          <Text style={styles.buttonText}>Flip</Text>
        </TouchableOpacity>
        
        {scanned && (
          <TouchableOpacity
            style={[styles.controlButton, styles.scanAgainButton]}
            onPress={() => setScanned(false)}
          >
            <Text style={styles.buttonText}>Scan Again</Text>
          </TouchableOpacity>
        )}
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: 'black' },
  centered: { flex: 1, alignItems: 'center', justifyContent: 'center', padding: 24 },
  text: { color: '#111', textAlign: 'center', marginBottom: 12 },
  button: { backgroundColor: '#2563eb', paddingHorizontal: 16, paddingVertical: 10, borderRadius: 8 },
  buttonText: { color: 'white', fontWeight: '600' },
  overlay: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    justifyContent: 'center',
    alignItems: 'center',
  },
  roleIndicator: {
    position: 'absolute',
    top: 60,
    left: 0,
    right: 0,
    alignItems: 'center',
  },
  roleText: {
    color: 'white',
    fontSize: 18,
    fontWeight: 'bold',
    backgroundColor: 'rgba(0,0,0,0.7)',
    paddingHorizontal: 16,
    paddingVertical: 8,
    borderRadius: 8,
  },
  scanArea: {
    width: 250,
    height: 250,
    justifyContent: 'center',
    alignItems: 'center',
  },
  scanFrame: {
    width: 250,
    height: 250,
    borderWidth: 2,
    borderColor: '#4CAF50',
    backgroundColor: 'transparent',
    borderRadius: 20,
  },
  scanText: {
    color: 'white',
    fontSize: 16,
    marginTop: 20,
    textAlign: 'center',
    backgroundColor: 'rgba(0,0,0,0.7)',
    paddingHorizontal: 16,
    paddingVertical: 8,
    borderRadius: 8,
  },
  controls: { 
    position: 'absolute', 
    bottom: 32, 
    left: 0, 
    right: 0, 
    alignItems: 'center',
    flexDirection: 'row',
    justifyContent: 'space-around',
    paddingHorizontal: 40,
  },
  controlButton: { 
    backgroundColor: 'rgba(0,0,0,0.4)', 
    paddingHorizontal: 16, 
    paddingVertical: 10, 
    borderRadius: 24,
    minWidth: 80,
    alignItems: 'center',
  },
  scanAgainButton: {
    backgroundColor: 'rgba(76, 175, 80, 0.8)',
  },
  fallbackContainer: {
    marginTop: 20,
    alignItems: 'center',
  },
  fallbackText: {
    fontSize: 14,
    color: '#666',
    marginBottom: 10,
  },
  fallbackButton: {
    backgroundColor: '#757575',
    paddingHorizontal: 16,
    paddingVertical: 10,
    borderRadius: 8,
  },
  fallbackButtonText: {
    color: 'white',
    fontWeight: '600',
    fontSize: 14,
  },
});


